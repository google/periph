// Copyright 2017 The Periph Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

package nrzled

import (
	"bytes"
	"image"
	"image/color"
	"strconv"
	"testing"

	"periph.io/x/periph/conn/gpio/gpiostream"
	"periph.io/x/periph/conn/gpio/gpiostream/gpiostreamtest"
	"periph.io/x/periph/conn/physic"
)

func TestNRZ(t *testing.T) {
	data := []struct {
		in       byte
		expected uint32
	}{
		{0x00, 0x924924},
		{0x01, 0x924926},
		{0x02, 0x924934},
		{0x04, 0x9249A4},
		{0x08, 0x924D24},
		{0x10, 0x926924},
		{0x20, 0x934924},
		{0x40, 0x9A4924},
		{0x80, 0xD24924},
		{0xFD, 0xDB6DA6},
		{0xFE, 0xDB6DB4},
		{0xFF, 0xDB6DB6},
	}
	for i, line := range data {
		t.Run(strconv.Itoa(i), func(t *testing.T) {
			if actual := NRZ(line.in); line.expected != actual {
				t.Fatalf("NRZ(%X): 0x%X != 0x%X", line.in, line.expected, actual)
			}
		})
	}
}

func TestNew_3(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		N: "Yo",
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92,
					0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49,
					0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92,
					0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49,
					0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, err := New(&g, 10, 400*physic.KiloHertz, 3)
	if err != nil {
		t.Fatal(err)
	}
	if s := d.String(); s != "nrzled{Yo}" {
		t.Fatal(s)
	}
	if c := d.ColorModel(); c != color.NRGBAModel {
		t.Fatal(c)
	}
	if r := d.Bounds(); r != image.Rect(0, 0, 10, 1) {
		t.Fatal(r)
	}
	if err = d.Halt(); err != nil {
		t.Fatal(err)
	}
	if err = g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestNew_fail(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{}
	if _, err := New(&g, 1, 0, 3); err == nil {
		t.Fatal("hz == 0")
	}
	if _, err := New(&g, 1, 400*physic.KiloHertz, 2); err == nil {
		t.Fatal("channels == 2")
	}
}

func TestDraw_NRGBA_3(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
					0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d,
					0xb6, 0x92, 0x49, 0xb6, 0x92, 0x49, 0xb4, 0x92, 0x4d, 0x24,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	img := image.NewNRGBA(d.Bounds())
	copy(img.Pix, getRGBW())
	d.Draw(d.Bounds(), img, image.Point{})
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestDraw_RGBA_3(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
					0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d,
					0xa6, 0xda, 0x49, 0xb6, 0xd3, 0x4d, 0x34, 0xdb, 0x49, 0x36,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	img := image.NewRGBA(d.Bounds())
	copy(img.Pix, getRGBW())
	d.Draw(d.Bounds(), img, image.Point{})
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestDraw_RGBA_4(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92,
					0x49, 0x24, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6,
					0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6,
					0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xa6, 0xd2, 0x49, 0x24, 0xda, 0x49, 0xb6, 0xd3,
					0x4d, 0x34, 0xdb, 0x49, 0x36, 0x92, 0x4d, 0x26,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 4)
	img := image.NewRGBA(d.Bounds())
	copy(img.Pix, getRGBW())
	d.Draw(d.Bounds(), img, image.Point{})
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestDraw_Limits(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
					0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d,
					0xa6, 0xda, 0x49, 0xb6, 0xd3, 0x4d, 0x34, 0xdb, 0x49, 0x36,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	img := image.NewRGBA(image.Rect(-1, -1, 20, 20))
	copy(img.Pix, getRGBW())
	d.Draw(d.Bounds(), img, image.Point{})
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestWrite_3(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{
		Ops: []gpiostream.Stream{
			&gpiostream.BitStream{
				Bits: []byte{
					0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49,
					0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0x92, 0x49, 0x24,
					0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0x24, 0xdb,
					0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0xdb, 0x6d, 0xb6, 0x92, 0x49, 0xa4, 0x92, 0x49, 0x36, 0x92, 0x49,
					0xa6, 0x92, 0x49, 0xb6, 0x92, 0x49, 0xb4, 0x92, 0x4d, 0x24,
				},
				Freq: 400 * physic.KiloHertz,
				LSBF: false,
			},
		},
	}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	if n, err := d.Write(getRGB()); n != 30 || err != nil {
		t.Fatal(n, err)
	}
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestWrite_fail(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{DontPanic: true}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	if n, err := d.Write([]byte{1}); n != 0 || err == nil {
		t.Fatal(n, err)
	}
	if n, err := d.Write([]byte{1, 2, 3}); n != 0 || err == nil {
		t.Fatal(n, err)
	}
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestHalt_fail(t *testing.T) {
	g := gpiostreamtest.PinOutPlayback{DontPanic: true}
	d, _ := New(&g, 10, 400*physic.KiloHertz, 3)
	if d.Halt() == nil {
		t.Fatal("expected failure")
	}
	if err := g.Close(); err != nil {
		t.Fatal(err)
	}
}

func TestRaster_3_3(t *testing.T) {
	data := []byte{
		// 24 bits per pixel in RGB
		0, 1, 2,
		0xFD, 0xFE, 0xFF,
	}
	expected := []byte{
		// 72 bits per pixel in GRB
		0x92, 0x49, 0x26, 0x92, 0x49, 0x24, 0x92, 0x49, 0x34,
		0xdb, 0x6d, 0xb4, 0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xb6,
	}
	actual := make([]byte, len(expected))
	raster(actual, data, 3, 3)
	if !bytes.Equal(expected, actual) {
		t.Fatalf("\nexpected %#v\n  actual %#v", expected, actual)
	}
}

func TestRaster_4_4(t *testing.T) {
	data := []byte{
		// 32 bits per pixel in RGBW
		0, 1, 2, 3,
		0xFC, 0xFD, 0xFE, 0xFF,
	}
	expected := []byte{
		// 96 bits per pixel in GRBW
		0x92, 0x49, 0x26, 0x92, 0x49, 0x24, 0x92, 0x49, 0x34, 0x92, 0x49, 0x36,
		0xdb, 0x6d, 0xa6, 0xdb, 0x6d, 0xa4, 0xdb, 0x6d, 0xb4, 0xdb, 0x6d, 0xb6,
	}
	actual := make([]byte, len(expected))
	raster(actual, data, 4, 4)
	if !bytes.Equal(expected, actual) {
		t.Fatalf("\nexpected %#v\n  actual %#v", expected, actual)
	}
}

//

func BenchmarkNRZ(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		NRZ(23)
	}
}

//

// getRGB returns a buffer of 10 RGB pixels.
func getRGB() []byte {
	return []byte{
		0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF,
		0x00, 0xFF, 0x00,
		0x00, 0xFF, 0xFF,
		0xFF, 0x00, 0x00,
		0xFF, 0x00, 0xFF,
		0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF,
		3, 4, 5,
		6, 7, 8,
	}
}

// getRGBW returns a buffer of 10 RGB pixels.
func getRGBW() []byte {
	return []byte{
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xFF,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0xFF, 0xFF, 0xFF,
		0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0x80,
		6, 7, 8, 9,
	}
}
